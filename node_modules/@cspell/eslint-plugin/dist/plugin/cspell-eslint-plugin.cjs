"use strict";
// cspell:ignore TSESTree
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugin = exports.configs = exports.meta = exports.rules = void 0;
const synckit_1 = require("synckit");
const logger_cjs_1 = require("../common/logger.cjs");
const schema_cjs_1 = require("../generated/schema.cjs");
const defaultCheckOptions_cjs_1 = require("./defaultCheckOptions.cjs");
const spellCheck = (0, synckit_1.createSyncFn)(require.resolve('../worker/worker.mjs'));
const messages = {
    wordUnknown: 'Unknown word: "{{word}}"',
    wordForbidden: 'Forbidden word: "{{word}}"',
    suggestWord: '{{word}}{{preferred}}',
};
const ruleMeta = {
    docs: {
        description: 'CSpell spellchecker',
        category: 'Possible Errors',
        recommended: false,
    },
    messages,
    hasSuggestions: true,
    fixable: 'code',
    schema: [schema_cjs_1.optionsSchema],
};
let isDebugMode = false;
function nullFix() {
    // eslint-disable-next-line unicorn/no-null
    return null;
}
function create(context) {
    const logger = (0, logger_cjs_1.getDefaultLogger)();
    const log = logger.log;
    const options = (0, defaultCheckOptions_cjs_1.normalizeOptions)(context.options[0], context.cwd || context.getCwd());
    const autoFix = options.autoFix;
    isDebugMode = options.debugMode ?? isDebugMode;
    logger.enabled = options.debugMode ?? (logger.enabled || isDebugMode);
    logContext(log, context);
    function reportIssue(issue) {
        const messageId = issue.severity === 'Forbidden' ? 'wordForbidden' : 'wordUnknown';
        const { word, start, end } = issue;
        const data = {
            word,
        };
        const code = contextSourceCode(context);
        const startPos = code.getLocFromIndex(start);
        const endPos = code.getLocFromIndex(end);
        const loc = { start: startPos, end: endPos };
        function fixFactory(word) {
            return (fixer) => fixer.replaceTextRange([start, end], word);
        }
        function createSug(sug) {
            const word = sug.wordAdjustedToMatchCase || sug.word;
            const preferred = sug.isPreferred ? '*' : '';
            const data = { word, preferred };
            const messageId = 'suggestWord';
            return {
                messageId,
                data,
                fix: fixFactory(word),
            };
        }
        // log('Suggestions: %o', issue.suggestions);
        const issueSuggestions = issue.suggestions;
        const fixable = issueSuggestions?.filter((sug) => !!sug.isPreferred);
        const canFix = fixable?.length === 1;
        const preferredSuggestion = autoFix && canFix && fixable[0];
        const fix = preferredSuggestion
            ? fixFactory(preferredSuggestion.wordAdjustedToMatchCase || preferredSuggestion.word)
            : nullFix;
        const suggestions = issueSuggestions?.map((sug) => createSug(sug));
        const suggest = suggestions;
        const des = {
            messageId,
            data,
            loc,
            suggest,
            fix,
        };
        context.report(des);
    }
    function checkProgram(_node) {
        const filename = context.filename || context.getFilename();
        const sc = context.sourceCode || context.getSourceCode();
        if (!sc)
            return;
        const { issues, errors } = spellCheck(filename, sc.text, sc.ast, options);
        if (errors && errors.length) {
            log('errors: %o', errors.map((e) => e.message));
            errors.forEach((error) => context.report({ message: error.message, loc: { line: 1, column: 1 } }));
        }
        issues.forEach((issue) => reportIssue(issue));
    }
    return { Program: checkProgram };
}
const spellchecker = {
    meta: ruleMeta,
    create,
};
exports.rules = {
    spellchecker,
};
function logContext(log, context) {
    log('context: %o', {
        id: context.id,
        cwd: context.cwd,
        filename: context.filename,
        physicalFilename: context.physicalFilename,
        // scope: context.getScope().type,
        options: context.options.length === 1 ? context.options[0] : context.options,
    });
}
function contextSourceCode(context) {
    return context.sourceCode || context.getSourceCode();
}
exports.meta = { name: '@cspell' };
const recommended = {
    plugins: ['@cspell'],
    rules: {
        '@cspell/spellchecker': ['warn', {}],
    },
};
const debugConfig = {
    plugins: ['@cspell'],
    rules: {
        '@cspell/spellchecker': ['warn', { debugMode: true }],
    },
};
exports.configs = {
    debug: debugConfig,
    'debug-legacy': debugConfig,
    recommended,
    'recommended-legacy': recommended,
};
exports.plugin = { rules: exports.rules, configs: exports.configs, meta: exports.meta };
//# sourceMappingURL=cspell-eslint-plugin.cjs.map