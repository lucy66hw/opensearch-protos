import assert from 'node:assert';
export class AstScopeMatcher {
    scope;
    constructor(scope) {
        this.scope = scope;
    }
    static fromScopeSelector(scopeSelector) {
        return new AstScopeMatcher(parseScope(scopeSelector).reverse());
    }
    /**
     * Score the astScope based on the given scope.
     * @param astScope The scope to score.
     * @returns The score of the scope. 0 = no match, higher the score the better the match.
     */
    score(astScope) {
        try {
            const scopeItems = astScope.map(parseScopeItem).reverse();
            return this.scoreItems(scopeItems);
        }
        catch {
            console.error('Failed to parse scope: %o', astScope);
            return 0;
        }
    }
    /**
     * Score the astScope based on the given scope.
     * @param astScope The scope to score.
     * @returns The score of the scope. 0 = no match, higher the score the better the match.
     */
    scoreItems(scopeItems) {
        const scope = this.scope;
        let score = 0;
        let scale = 1;
        let matchKey = false;
        for (let i = 0; i < scope.length; i++) {
            const item = scopeItems[i];
            if (!item)
                return 0;
            const curr = scope[i];
            if (curr.type !== item.type)
                return 0;
            if (curr.childKey && item.childKey && curr.childKey !== item.childKey)
                return 0;
            if (curr.childKey && !item.childKey && matchKey)
                return 0;
            if (curr.childKey && (curr.childKey == item.childKey || !matchKey)) {
                score += scale;
            }
            score += scale * 2;
            matchKey = true;
            scale *= 4;
        }
        return score;
    }
    matchPath(path) {
        const s = this.scope[0];
        // Early out
        if (s?.type !== path.node.type)
            return 0;
        const items = astPathToScopeItems(path);
        return this.scoreItems(items);
    }
    scopeField() {
        return this.scope[0]?.childKey || 'value';
    }
    scopeType() {
        return this.scope[0]?.type || '';
    }
}
export function scopeItem(type, childKey) {
    return { type, childKey };
}
const regexValidScope = /^([\w.-]+)(?:\[([\w<>.-]*)\])?$/;
function parseScopeItem(item) {
    const match = item.match(regexValidScope);
    assert(match, `Invalid scope item: ${item}`);
    const [_, type, key] = match;
    return { type, childKey: key || undefined };
}
export function parseScope(scope) {
    return scope
        .split(' ')
        .filter((s) => s)
        .map(parseScopeItem);
}
export function keyToString(key) {
    return key === undefined || key === null
        ? undefined
        : typeof key === 'symbol'
            ? `<${Symbol.keyFor(key)}>`
            : `${key}`;
}
export function mapNodeToScope(p, key) {
    return mapNodeToScopeItem(p, key);
}
export function mapNodeToScopeItem(p, childKey) {
    return scopeItem(p.node.type, keyToString(childKey));
}
export function mapScopeItemToString(item) {
    const { type, childKey: k } = item;
    return k === undefined ? type : `${type}[${k}]`;
}
/**
 * Convert an ASTPath to a scope.
 * @param path - The path to convert to a scope.
 * @returns
 */
export function astPathToScope(path, mapFn = mapNodeToScope) {
    return astPathToScopeItems(path, mapFn).map(mapScopeItemToString).reverse();
}
export function astScopeToString(path, sep = ' ', mapFn) {
    return astPathToScope(path, mapFn).join(sep);
}
export function astPathToScopeItems(path, mapFn = mapNodeToScope) {
    const parts = [];
    let key = undefined;
    while (path) {
        parts.push(mapFn(path, key));
        key = path?.key;
        path = path.prev;
    }
    return parts;
}
export class AstPathScope {
    path;
    items;
    constructor(path) {
        this.path = path;
        this.items = astPathToScopeItems(path);
    }
    get scope() {
        return this.items.map(mapScopeItemToString).reverse();
    }
    get scopeItems() {
        return this.items;
    }
    get scopeString() {
        return this.scope.join(' ');
    }
    score(matcher) {
        const field = matcher.scopeField();
        const node = this.path.node;
        if (field in node && typeof node[field] === 'string') {
            return matcher.scoreItems(this.items);
        }
        return 0;
    }
}
//# sourceMappingURL=scope.mjs.map